% -*- coding: utf-8 -*-
\NeedsTeXFormat{LaTeX2e}
\ProvidesPackage{interchar}[2015/02/01 v0.1]
\RequirePackage{expl3}
\RequirePackage{xparse}

\ExplSyntaxOn

% Some more scratch variables
\tl_new:N \l__interchar_a_tl
\tl_new:N \l__interchar_b_tl
\tl_new:N \l__interchar_x_tl
\tl_new:N \l__interchar_y_tl
\tl_new:N \l__interchar_ab_tl
\tl_new:N \l__interchar_xy_tl

% Generate variants for some functions
\cs_generate_variant:Nn \clist_concat:NNN { c }
\cs_generate_variant:Nn \int_to_hexadecimal:n { V }
\cs_generate_variant:Nn \prop_get:cn { cx }
\cs_generate_variant:Nn \prop_get:NnN { cx }
\cs_generate_variant:Nn \prop_put:Nnn { cx }
\cs_generate_variant:Nn \tl_if_eq:nnT { Vo }

% Renaming some primitive commands of XeTeX
\cs_new_eq:NN \xetex_intercharstate:D \XeTeXinterchartokenstate
\cs_new_eq:NN \xetex_newcharclass:D \newXeTeXintercharclass
\cs_new_eq:NN \xetex_charclass:D \XeTeXcharclass
\cs_new_eq:NN \xetex_interchartoks:D \XeTeXinterchartoks

% Need to update them according to unicode-letters.tex
\clist_new:N \g_interchar_default_classes_clist
\clist_gset:Nn \g_interchar_default_classes_clist { 1, 2, 3 }
\int_new:N  \g_interchar_default_newclass_int
\int_gset:Nn \g_interchar_default_newclass_int { 4 }
\clist_new:c { g_interchar_default_chars_0_clist }
\clist_gset:cn { g_interchar_default_chars_0_clist }
  {
    1-3000, 3003-3007, 3010-33FF, 4DB6-4DFF, 9FCD-FF07, FF0A-FF0B, FF0D, FF0F-FFFF
  }
\clist_new:c { g_interchar_default_chars_1_clist }
\clist_gset:cn { g_interchar_default_chars_1_clist }
  {
    3400-4DB5, 4E00-9FCC
  }
\clist_new:c  { g_interchar_default_chars_2_clist }
\clist_gset:cn { g_interchar_default_chars_2_clist }
  {
    3008, 300A, 300C, 300E, FF08
  }
\clist_new:c { g_interchar_default_chars_3_clist }
\clist_gset:cn { g_interchar_default_chars_3_clist }
  {
    3001-3002, 3009, 300B, 300D, 300F, FF09, FF0C, FF0E
  }
\prop_new:N \g_interchar_default_toks_prop
\prop_gput:Nnn \g_interchar_default_toks_prop {0~1} {\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {0~2} {\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {0~3} {\nobreak\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {1~0} {\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {2~0} {\nobreak\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {3~0} {\xtxHanSpace}
\prop_gput:Nnn \g_interchar_default_toks_prop {1~1} {\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {1~2} {\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {1~3} {\nobreak\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {2~1} {\nobreak\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {2~2} {\nobreak\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {2~3} {\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {3~1} {\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {3~2} {\xtxHanGlue}
\prop_gput:Nnn \g_interchar_default_toks_prop {3~3} {\nobreak\xtxHanGlue}

% Create a new interchar scheme for each package
\msg_new:nnn { interchar } { Empty-Argument }
  {
    The~argument~should~not~be~empty!
  }

\tl_new:N \g_interchar_current_scheme_tl
\tl_gset:Nn \g_interchar_current_scheme_tl {default}

\NewDocumentCommand \newintercharscheme { m }
  {
    \tl_if_empty:nT {#1} { \msg_critical:nn { interchar } { Empty-Argument } }
    \clist_new:c { g_interchar_#1_classes_clist }
    \clist_gset:cn { g_interchar_#1_classes_clist } { 1, 2, 3 }
    \int_new:c { g_interchar_#1_newclass_int }
    \int_gset:cn { g_interchar_#1_newclass_int } { 4 }
    \clist_new:c { g_interchar_#1_chars_1_clist }
    \clist_new:c { g_interchar_#1_chars_2_clist }
    \clist_new:c { g_interchar_#1_chars_3_clist }
    \prop_new:c { g_interchar_#1_toks_prop }
    % Used for migrating from XeTeX's primitive commands
    \interchar@migration { #1 }
  }

% High level \intercharstate command
% #1: scheme name; #2: state code
\NewDocumentCommand \intercharstate { O{default} m }
  {
    \interchar_state:nn {#1} {#2}
  }
\cs_new_protected_nopar:Npn \interchar_state:nn #1#2
  {
    \__interchar_clear_toks:V \g_interchar_current_scheme_tl
    \clist_map_inline:Nn \g_interchar_default_classes_clist
        { \__interchar_apply_class:nn {default} {##1} }
    \__interchar_apply_class:nn {default} {0}
    \__interchar_apply_toks:n {default}
    \int_compare:nTF { #2 > 0 }
      {
        \clist_map_inline:cn { g_interchar_#1_classes_clist }
            { \__interchar_apply_class:nn {#1} {##1} }
        \__interchar_apply_toks:n {#1}
        % Use \tl_gset:Nx rathar than \tl_gset:Nn here
        \tl_gset:Nx \g_interchar_current_scheme_tl {#1}
      }
      { \tl_gset:Nn \g_interchar_current_scheme_tl {default} }
  }
\cs_generate_variant:Nn \interchar_state:nn { VV }

% #1: scheme name; #2: class number
\cs_new_protected_nopar:Npn \__interchar_apply_class:nn #1#2
  {
    \clist_map_inline:cn
      { g_interchar_#1_chars_ \int_to_arabic:n{#2} _clist }
      {
        \__interchar_class_split_range:nNN {##1} \l_tmpa_tl \l_tmpb_tl
        \int_set:Nn \l_tmpa_int { "\l_tmpa_tl }
        \int_set:Nn \l_tmpb_int { "\l_tmpb_tl }
        \int_while_do:nn { \l_tmpa_int <= \l_tmpb_int }
          {
            \xetex_charclass:D \l_tmpa_int = #2
            \int_incr:N \l_tmpa_int
          }
      }
  }

% #1: scheme name
\cs_new_protected_nopar:Npn \__interchar_apply_toks:n #1
  {
    \prop_map_inline:cn { g_interchar_#1_toks_prop }
      { \xetex_interchartoks:D ##1 = {##2} }
  }

% #1: scheme name
\cs_new_protected_nopar:Npn \__interchar_clear_toks:n #1
  {
    \prop_map_inline:cn { g_interchar_#1_toks_prop }
      { \xetex_interchartoks:D ##1 = {} }
  }
\cs_generate_variant:Nn \__interchar_clear_toks:n { V }

% High level \getintercharstate command
% #1: scheme name; result: state code
\DeclareExpandableDocumentCommand \getintercharstate { m }
  {
    \interchar_get_state:n {#1}
  }
\cs_new_nopar:Npn \interchar_get_state:n #1
  {
    \str_if_eq:VnTF \g_interchar_current_scheme_tl { #1 } { 1 } { 0 }
  }

% High level \intercharnewclass command
% #1: scheme name; #2: control sequence for class number
\NewDocumentCommand \newintercharclass { O{default} m}
  {
    \interchar_newclass:nn { #1 } { #2 }
  }
\cs_new_protected_nopar:Npn \interchar_newclass:nn #1#2
  {
    \int_set:Nn \l_tmpa_int { \int_use:N \use:c {g_interchar_#1_newclass_int} }
    \int_new:N #2
    \int_set_eq:NN #2 \l_tmpa_int
    \clist_put_right:co {g_interchar_#1_classes_clist} {\int_use:N \l_tmpa_int}
    \clist_new:c { g_interchar_#1_chars_ \int_use:N\l_tmpa_int _clist }
    \int_incr:c { g_interchar_#1_newclass_int }
  }

% High level \intercharclass command
% #1: scheme name; #2: class number; #3: char code
\NewDocumentCommand \intercharclass { O{default} m m }
  {
    \interchar_class:nnn {#1} {#2} {#3}
  }
\bool_new:N \g__interchar_class_delete_char_bool
\cs_new_protected_nopar:Npn \interchar_class:nnn #1#2#3
  {
    \int_compare:nT { #2 > 0 }
      {
        \int_set:Nn \l_tmpa_int {#2}
        \clist_if_in:coF {g_interchar_#1_classes_clist}
          { \int_use:N \l_tmpa_int }
          {
            \clist_put_right:co { g_interchar_#1_classes_clist }
                { \int_use:N\l_tmpa_int }
            \clist_new:c
                { g_interchar_#1_chars_ \int_use:N\l_tmpa_int _clist }
          }
        \__interchar_class_insert_char:nnn {#1} {#2} {#3}
      }
    \bool_set_false:N \g__interchar_class_delete_char_bool
    \clist_map_inline:cn {g_interchar_#1_classes_clist}
      {
        \int_compare:nT { #2 != ##1 }
          {
            \bool_if:NTF \g__interchar_class_delete_char_bool
              { \clist_map_break: }
              { \__interchar_class_delete_char:nnn {#1} {##1} {#3} }
          }
      }
  }
\cs_generate_variant:Nn \interchar_class:nnn { VVV }

% #1: scheme name; #2: class number; #3 char range
\cs_new_protected_nopar:Npn \__interchar_class_insert_char:nnn #1#2#3
  {
    % store all char ranges before #3
    \clist_clear:N \l_tmpa_clist
    % store all char ranges after #3
    \clist_set_eq:Nc
        \l_tmpb_clist { g_interchar_#1_chars_ \int_to_arabic:n{#2} _clist }
    \__interchar_class_split_range:nNN {#3} \l__interchar_a_tl \l__interchar_b_tl
    \tl_set:Nx \l_tmpa_tl { \int_to_hexadecimal:V \l__interchar_a_tl }
    \tl_set:Nx \l_tmpb_tl { \int_to_hexadecimal:V \l__interchar_b_tl }
    % if correct position found
    \bool_set_false:N \l_tmpa_bool
    \bool_do_until:Nn \l_tmpa_bool
      {
        \tl_if_empty:NTF \l_tmpb_clist
          { \bool_set_true:N \l_tmpa_bool }
          {
            \clist_pop:NN \l_tmpb_clist \l__interchar_xy_tl
            \exp_args:NV \__interchar_class_split_range:nNN
                { \l__interchar_xy_tl } \l__interchar_x_tl \l__interchar_y_tl
            \int_compare:nTF { "\l__interchar_y_tl < "\l_tmpa_tl - 1 }
              {
                % left
                \clist_put_right:NV \l_tmpa_clist \l__interchar_xy_tl
              }
              {
                \int_compare:nTF { "\l__interchar_x_tl > "\l_tmpb_tl + 1}
                  {
                    % right
                    \clist_put_left:NV \l_tmpb_clist \l__interchar_xy_tl
                    \bool_set_true:N \l_tmpa_bool
                  }
                  {
                    % middle
                    \int_compare:nT { "\l__interchar_x_tl < "\l_tmpa_tl }
                        { \tl_set_eq:NN \l_tmpa_tl \l__interchar_x_tl }
                    \int_compare:nT { "\l__interchar_y_tl > "\l_tmpb_tl }
                        { \tl_set_eq:NN \l_tmpb_tl \l__interchar_y_tl }
                  }
              }
          }
      }
    \tl_if_eq:NNTF \l_tmpa_tl \l_tmpb_tl
      { \tl_set_eq:NN \l__interchar_ab_tl \l_tmpa_tl }
      { \tl_set:Nx \l__interchar_ab_tl { \l_tmpa_tl - \l_tmpb_tl } }
    \clist_put_right:NV \l_tmpa_clist \l__interchar_ab_tl
    \clist_concat:cNN { g_interchar_#1_chars_ \int_to_arabic:n{#2} _clist }
                       \l_tmpa_clist \l_tmpb_clist
  }

% High level \intercharclass command
% #1: scheme name; #2: class number; #3: char range
\cs_new_protected_nopar:Npn \__interchar_class_delete_char:nnn #1#2#3
  {
    % store all char ranges before #3
    \clist_clear:N \l_tmpa_clist
    % store all char ranges after #3
    \clist_set_eq:Nc
        \l_tmpb_clist { g_interchar_#1_chars_ \int_to_arabic:n{#2} _clist }
    \__interchar_class_split_range:nNN {#3} \l__interchar_a_tl \l__interchar_b_tl
    \tl_set:Nx \l_tmpa_tl { \int_to_hexadecimal:V \l__interchar_a_tl }
    \tl_set:Nx \l_tmpb_tl { \int_to_hexadecimal:V \l__interchar_b_tl }
    % if correct position found
    \bool_set_false:N \l_tmpa_bool
    \bool_do_until:Nn \l_tmpa_bool
      {
        \tl_if_empty:NTF \l_tmpb_clist
          { \bool_set_true:N \l_tmpa_bool }
          {
            \clist_pop:NN \l_tmpb_clist \l__interchar_xy_tl
            \exp_args:NV \__interchar_class_split_range:nNN
                { \l__interchar_xy_tl } \l__interchar_x_tl \l__interchar_y_tl
            \int_compare:nTF { "\l__interchar_y_tl < "\l_tmpa_tl}
              {
                % left
                \clist_put_right:NV \l_tmpa_clist \l__interchar_xy_tl
              }
              {
                \int_compare:nTF { "\l__interchar_x_tl > "\l_tmpb_tl}
                  {
                    % right
                    \clist_put_left:NV \l_tmpb_clist \l__interchar_xy_tl
                    \bool_set_true:N \l_tmpa_bool
                  }
                  {
                    % middle: put [x,a-1] and [b+1,y] into clist
                    \int_compare:nTF { "\l_tmpa_tl - "\l__interchar_x_tl = 1 }
                      {
                        \clist_put_right:NV \l_tmpa_clist \l__interchar_x_tl
                      }
                      {
                        \int_compare:nT { "\l_tmpa_tl - "\l__interchar_x_tl > 1 }
                        {
                          \tl_set:Nx \l__interchar_z_tl
                              { \int_to_hexadecimal:n { "\l_tmpa_tl - 1 } }
                          \clist_put_right:Nx \l_tmpa_clist
                              { \l__interchar_x_tl - \l__interchar_z_tl }
                        }
                      }
                    \int_compare:nTF { "\l__interchar_y_tl - "\l_tmpb_tl = 1 }
                      {
                        \clist_put_right:NV \l_tmpa_clist \l__interchar_y_tl
                      }
                      {
                        \int_compare:nT { "\l__interchar_y_tl - "\l_tmpb_tl > 1 }
                        {
                          \tl_set:Nx \l__interchar_z_tl
                              { \int_to_hexadecimal:n { "\l_tmpb_tl + 1 } }
                          \clist_put_right:Nx \l_tmpa_clist
                              { \l__interchar_z_tl - \l__interchar_y_tl }
                        }
                      }
                    \tl_if_eq:NNT \l_tmpa_tl \l_tmpb_tl
                        { \bool_set_true:N \g__interchar_class_delete_char_bool }
                  }
              }
          }
      }
    \clist_concat:cNN { g_interchar_#1_chars_ \int_to_arabic:n{#2} _clist }
                       \l_tmpa_clist \l_tmpb_clist
  }

% Split #1 with - and put the results into #2 and #3
\NewDocumentCommand \__interchar_class_split_range:nNN
  { > { \SplitArgument { 1 } { - } } m m m}
  {
    \tl_set:No #2 { \use_i:nn #1}
    \tl_set:No #3 { \use_ii:nn #1}
    \exp_args:No \IfNoValueT {#3} { \tl_set_eq:NN #3 #2 }
  }

% High level \interchartoks command
% #1: scheme name; #2 and #3: class numbers; #4: tokens
\NewDocumentCommand \interchartoks { O{default} m m +m }
  {
    \interchar_toks:nnnn {#1} {#2} {#3} {#4}
  }
\cs_new_protected_nopar:Npn \interchar_toks:nnnn #1#2#3#4
  {
    \int_set:Nn \l_tmpa_int {#2}
    \int_set:Nn \l_tmpb_int {#3}
    \prop_put:cxn { g_interchar_#1_toks_prop }
        { \int_use:N \l_tmpa_int \c_space_tl \int_use:N \l_tmpb_int }
        { #4 }
    \tl_if_eq:VoT \g_interchar_current_scheme_tl { #1 }
      {
        \xetex_interchartoks:D \l_tmpa_int \l_tmpb_int = { #4 }
      }
  }
\cs_generate_variant:Nn \interchar_toks:nnnn { VVVV }

% #1: scheme name; #2 and #3: class numbers
% This function is exhaustively expandable
\cs_new_nopar:Npn \interchar_get_toks:nnn #1#2#3
  {
    \prop_get:cx { g_interchar_#1_toks_prop } { #2 \c_space_tl #3 }
  }
\cs_generate_variant:Nn \interchar_get_toks:nnn { VVV }

% #1: scheme name; #2 and #3: class numbers; #4: result control sequence
\cs_new_protected_nopar:Npn \interchar_get_toks:nnnN #1#2#3#4
  {
    \int_set:Nn \l_tmpa_int {#2}
    \int_set:Nn \l_tmpb_int {#3}
    \prop_get:cxN { g_interchar_#1_toks_prop }
        { \int_use:N \l_tmpa_int \c_space_tl \int_use:N \l_tmpb_int } #4
    \quark_if_no_value:NT #4 { \tl_clear:N #4 }
  }

\xetex_intercharstate:D = 1

\ExplSyntaxOff

% We need to call LaTeX3 functions
\catcode `\_ = 11 \catcode `\: = 11

% From now on, we use \newcommand for commands, \def for variables

% First we define some variables
\def\interchar@scheme@name@tl{}
\def\interchar@tmpa@int{}
\def\interchar@tmpb@int{}
\def\interchar@tmpa@tl{}

% Used for migrating from XeTeX's primitive commands

% We want to make the following usages work for \FOOinterchartokenstate:
% - \FOOinterchartokenstate = 1
% - \the\FOOinterchartokenstate
% - \ifnum \the\FOOinterchartokenstate > 0 doA \else doB \fi
% The following trick is based on egreg's answer to the question
% See http://tex.stackexchange.com/a/227298/8956
\newtoks\interchar@get@toks
\interchar@get@toks = {\interchar@gobble}
\newcommand\interchar@gobble[6]{\interchar_get_state:n{#5}}

% #1: scheme name
\newcommand\interchar@migration[1]{%
  \expandafter\newcommand\csname #1interchartokenstate\endcsname{%
    \interchar@get@toks = {\interchar@gobble}%
    \def\interchar@scheme@name@tl{#1}%
    \interchar@state@auxi
  }%
  \expandafter\newcommand\csname new#1intercharclass\endcsname[1]{%
    \interchar_newclass:nn {#1} {##1}%
  }%
  \expandafter\newcommand\csname #1charclass\endcsname{%
    \def\interchar@scheme@name@tl{#1}%
    \interchar@class@auxi
  }%
  \expandafter\newcommand\csname #1interchartoks\endcsname{%
    \def\interchar@scheme@name@tl{#1}%
    \interchar@toks@auxi
  }%
}

% Commands for scanning number or toks arguments
\newcommand\interchar@scan@number[1]{%
  \afterassignment#1\count255 %
}
\newcommand\interchar@scan@number@x[1]{%
  \afterassignment#1\count255=%
}
\newcommand\interchar@scan@toks[1]{%
  \afterassignment#1\toks0 %
}

% Scanning arguments of \FOOinterchartokenstate command
\newcommand\interchar@state@auxi{%
  \interchar@scan@number \interchar@state@auxii
}
\newcommand\interchar@state@auxii{%
  \edef\interchar@tmpa@int{\the\count255}%
  \interchar_state:VV \interchar@scheme@name@tl \interchar@tmpa@int
}

% Scanning arguments of \FOOcharclass command
\newcommand\interchar@class@auxi{%
  \interchar@scan@number@x \interchar@class@auxii
}
\newcommand\interchar@class@auxii{%
  \edef\interchar@tmpa@int{\the\count255}%
  \interchar@scan@number \interchar@class@auxiii
}
\newcommand\interchar@class@auxiii{%
  \edef\interchar@tmpb@int{\the\count255}%
  \interchar_class:VVV \interchar@scheme@name@tl
          \interchar@tmpb@int \interchar@tmpa@int
}

% Scanning arguments of \FOOinterchartoks command
\newcommand\interchar@toks@auxi{%
  \interchar@scan@number@x \interchar@toks@auxii
}
\newcommand\interchar@toks@auxii{%
  \edef\interchar@tmpa@int{\the\count255}%
  \interchar@scan@number@x \interchar@toks@auxiii
}
\newcommand\interchar@toks@auxiii{%
  \edef\interchar@tmpb@int{\the\count255}%
  \interchar@scan@toks \interchar@toks@auxiv
}
\newcommand\interchar@toks@auxiv{%
  \edef\interchar@tmpa@tl{\the\toks0}%
  \interchar_toks:VVVV \interchar@scheme@name@tl
          \interchar@tmpa@int \interchar@tmpb@int \interchar@tmpa@tl
}

% Recover catcode changes
\catcode `\_ = 8 \catcode `\: = 12
